<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Career Builder Journey</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />

    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Funnel+Sans:ital@0;1&display=swap" rel="stylesheet">
  </head>
  <body>
    <div class="journey"></div>
    
     <script>
        //settings
        let currentStep = 4;
        let totalSteps = 9;
        let isScrolling = false;
        let startX = 0;
        let scrollLeft = 0;
        let scrollUpdateTimeout = null;

        // Function to recalculate transform positions on resize
        function recalculateTransforms() {
          const steps = document.querySelectorAll('.step');
          const journeyHeight = document.querySelector('.journey').offsetHeight;
          
          steps.forEach((step, index) => {
            const stepNumber = index + 1;
            let verticalPosition = 5;

            if (stepNumber % 2 === 0) {
              verticalPosition = 2.5;
            }
            if (stepNumber % 3 === 0) {
              verticalPosition = 7;
            }

            const stepTransformY = journeyHeight / 2 * (verticalPosition - 5) / 5;
            const offset = (verticalPosition > 5 && verticalPosition != 5) ? -24 : 0;
            
            step.style.transform = `translateY(${stepTransformY + offset}px)`;
          });

          // Recalculate scroll position after resize
          setTimeout(() => {
            scrollToCurrent();
            triggerScroll(document.querySelector('.journey').scrollLeft);
          }, 100);
        }

        // Add resize event listener
        window.addEventListener('resize', () => {
          if (scrollUpdateTimeout) clearTimeout(scrollUpdateTimeout);
          scrollUpdateTimeout = setTimeout(recalculateTransforms, 250);
        });

        //creating journey html
        function renderJourney(currentStep,totalSteps) {
          let content = '<div class="journey__inner">';

          let polyPointsComplete = '';
          let polyPoints = '';
          let initPolyPointsComplete = '';
          let initPolyPoints = '';

          for (let i = 0; i < totalSteps; i++) {
            
            const stepComplete = (i < currentStep - 1);
            const stepCurrent = (i == currentStep - 1);
            const stepLast = (i == totalSteps - 1);
            const increment = (100 / (totalSteps - 1)).toFixed(2); 
            const defaultPosition = 5; 

            let stepClasses = 'step';
            stepClasses += stepComplete ? ' complete' : '';
            stepClasses += stepCurrent ? ' current' : '';
            stepClasses += stepLast ? ' last' : '';

            let verticalPosition = defaultPosition;

            if ((i + 1) % 2 === 0) {
              verticalPosition = 2.5;
            }
            if ((i + 1) % 3 === 0) {
              verticalPosition = 7;
            }             

            const journeyHeight = document.querySelector('.journey').offsetHeight;
            const stepTransformY = journeyHeight / 2 * (verticalPosition - 5) / 5;
            const offset = (verticalPosition > defaultPosition && verticalPosition != defaultPosition) ? -24 : 0;
            const randomImageNumber = Math.floor(Math.random() * 4) + 1;

            polyPoints +=  (increment * i) + ' ' + verticalPosition + ' ';
            initPolyPoints +=  (increment * i) + ' ' + defaultPosition + ' ';

            if(stepComplete || stepCurrent) {
              polyPointsComplete +=  (increment * i) + ' ' + verticalPosition + ' ';
              initPolyPointsComplete += increment * i + ' ' + defaultPosition + ' ';
            }
            
            content += '<div class="' + stepClasses + '" style="transform: translateY(' + (stepTransformY + offset) + 'px)">';
 
            if(stepCurrent && !stepLast) {
              content += '<div class="character__wrap"><div class="character">\
              <img src="./img/journey-character.svg"/>\
            </div>';
            }

            if(stepComplete) {
              
              content += '<div class="badge material-symbols-outlined">check</div><img src="./img/journey-stone-' + randomImageNumber + '-complete.svg" class="stone"/>';
          
            } else if (stepLast) {

              content += '<img src="./img/journey-destination.png" class="destination"/><img src="./img/journey-planet.svg" class="stone"/>';

            } else {

              content += '<div class="badge"></div><img src="./img/journey-stone-' + randomImageNumber + '.svg" class="stone"/>';
          
            }

            if(stepCurrent) {
              content += '</div>';
            }

            content += '</div>';

          } //end loop

          content += '</div>';

          document.querySelector('.journey').insertAdjacentHTML('beforeend',content);

          //doing this to calculate length of polyline before render
          const svgNS = "http://www.w3.org/2000/svg";
          const polyline = document.createElementNS(svgNS, "polyline");
          polyline.setAttribute("points", polyPointsComplete); 
          
          // Temporarily add to DOM to calculate length, then remove
          const tempSvg = document.createElementNS(svgNS, "svg");
          tempSvg.appendChild(polyline);
          document.body.appendChild(tempSvg);
          const currentLineLength = polyline.getTotalLength();
          document.body.removeChild(tempSvg);

          const svg = '<div class="line"><svg viewBox="0 0 100 10" preserveAspectRatio="none" fill="none" xmlns="http://www.w3.org/2000/svg"><polyline class="inprogress" points="' + initPolyPoints + '"><animate fill="freeze" dur="0.5s" attributeName="points" begin="0s"   to="' + polyPoints + '"/></polyline><polyline class="completeline"  points="' + initPolyPointsComplete + '" stroke-dasharray="' + currentLineLength + '" stroke-dashoffset="' + currentLineLength + '"><animate fill="freeze" dur="0.5s" begin="0s" attributeName="points" to="' + polyPointsComplete + '"/></polyline></svg></div>';

          document.querySelector('.journey__inner').insertAdjacentHTML('beforeend',svg);

          //initial styling/animations
          const currentLine = document.querySelector('.completeline'); 

          setTimeout(function() {
            currentLine.classList.add('active');
          }, 500);

          renderControls();
          scrollToCurrent();
          setupSwipeHandlers();

        }

        //inserting controls html
        function renderControls() {

          const controls = '<div class="controls"><div class="controls__buttons"><button class="slide-left material-symbols-outlined">arrow_back</button><button class="slide-right material-symbols-outlined">arrow_forward</button></div><div class="controls__scrollbar"><div class="scrollbar__inner"></div></div>';

          document.querySelector('.journey').insertAdjacentHTML('afterend',controls);
        }

        function setupSwipeHandlers() {
          const container = document.querySelector('.journey');
          
          container.addEventListener('touchstart', handleTouchStart, { passive: false });
          container.addEventListener('touchmove', handleTouchMove, { passive: false });
          container.addEventListener('touchend', handleTouchEnd, { passive: false });
          
          container.addEventListener('mousedown', handleMouseDown);
          container.addEventListener('mousemove', handleMouseMove);
          container.addEventListener('mouseup', handleMouseUp);
          container.addEventListener('mouseleave', handleMouseUp);
          
          container.addEventListener('dragstart', (e) => e.preventDefault());
        }

        //touch/interaction 
        function handleTouchStart(e) {
          e.preventDefault();
          const container = document.querySelector('.journey');
          startX = e.touches[0].pageX - container.offsetLeft;
          scrollLeft = container.scrollLeft;
          isScrolling = true;
        }

        function handleTouchMove(e) {
          if (!isScrolling) return;
          e.preventDefault();
          const container = document.querySelector('.journey');
          const x = e.touches[0].pageX - container.offsetLeft;
          const walk = (x - startX) * 2; 
          container.scrollLeft = scrollLeft - walk;
          
          if (scrollUpdateTimeout) clearTimeout(scrollUpdateTimeout);
          scrollUpdateTimeout = setTimeout(() => {
            triggerScroll(container.scrollLeft);
          }, 16); // ~60fps
        }

        function handleTouchEnd(e) {
          isScrolling = false;
          const container = document.querySelector('.journey');
          triggerScroll(container.scrollLeft);
        }

        function handleMouseDown(e) {
          const container = document.querySelector('.journey');
          startX = e.pageX - container.offsetLeft;
          scrollLeft = container.scrollLeft;
          isScrolling = true;
          container.style.cursor = 'grabbing';
        }

        function handleMouseMove(e) {
          if (!isScrolling) return;
          e.preventDefault();
          const container = document.querySelector('.journey');
          const x = e.pageX - container.offsetLeft;
          const walk = (x - startX) * 2;
          container.scrollLeft = scrollLeft - walk;
          
          if (scrollUpdateTimeout) clearTimeout(scrollUpdateTimeout);
          scrollUpdateTimeout = setTimeout(() => {
            triggerScroll(container.scrollLeft);
          }, 16); // ~60fps
        }

        function handleMouseUp(e) {
          isScrolling = false;
          const container = document.querySelector('.journey');
          container.style.cursor = 'grab';
          
          triggerScroll(container.scrollLeft);
        }

        //create scrollbar/click
        function triggerScroll(scrollLeft) {
          try {
            const container = document.querySelector('.journey');
            const buttonRight = document.querySelector('.slide-right');
            const buttonLeft = document.querySelector('.slide-left');

            const scrollOffset = scrollLeft / container.scrollWidth * 100;
            const scrollWidth = container.offsetWidth / container.scrollWidth;
            const scrollbar = document.querySelector('.scrollbar__inner');

            const scrollAmount = Math.min(container.offsetWidth * 0.8, 300);

            buttonRight.onclick = function () {
              const newScrollLeft = container.scrollLeft + scrollAmount;
              container.scrollTo({
                left: newScrollLeft,
                behavior: 'smooth'
              });
              triggerScroll(newScrollLeft);
            };

            buttonLeft.onclick = function () {
              const newScrollLeft = container.scrollLeft - scrollAmount;
              container.scrollTo({
                left: newScrollLeft,
                behavior: 'smooth'
              });
              triggerScroll(newScrollLeft);
            };

            scrollbar.style.left = scrollOffset + '%';
            scrollbar.style.width = scrollWidth * 200 + 'px';

            if(container.scrollWidth > container.offsetWidth) {
                document.querySelector('.controls').style.display = 'block';
                container.style.justifyContent = 'start';

            } else {
              container.style.justifyContent = 'center';
            }
          } catch (error) {
            console.error('Error in triggerScroll:', error);
          }
        }
 
        //ensure current step starts in view
        function scrollToCurrent() {
          try {
            const container = document.querySelector('.journey');
            const currentElement = document.querySelector('.current');
            
            if (!currentElement) {
              triggerScroll(0);
              return;
            }
            
            const currentPlacementX = currentElement.getBoundingClientRect().left;
            const containerRect = container.getBoundingClientRect();

            if( currentPlacementX > containerRect.width) {
                container.scrollTo({
                  left: currentPlacementX - containerRect.width / 2,
                  behavior: 'smooth'
                });
                triggerScroll(currentPlacementX - containerRect.width / 2);
            } else {
              triggerScroll(0);
            }
          } catch (error) {
            console.error('Error in scrollToCurrent:', error);
          }
        }

        //edit button controls
        function changeJourney() {
          try {
            currentStep = parseInt(document.querySelector('input[name=currentStep]').value) || 1;
            totalSteps = parseInt(document.querySelector('input[name=totalSteps]').value) || 6;

            //remove current
            document.querySelector('.journey').innerHTML = '';
            document.querySelector('.controls').remove();

            //recreate
            renderJourney(currentStep,totalSteps);
          } catch (error) {
            console.error('Error in changeJourney:', error);
          }
        }
        
        // Initialize with error handling
        try {
          renderJourney(currentStep, totalSteps);
        } catch (error) {
          console.error('Error initializing journey:', error);
        }

        // Performance monitoring
        function logPerformance() {
          const container = document.querySelector('.journey');
          const steps = document.querySelectorAll('.step');
          console.log('Performance Info:', {
            totalSteps: steps.length,
            containerWidth: container?.offsetWidth,
            scrollWidth: container?.scrollWidth,
            memoryUsage: performance.memory ? {
              used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024) + 'MB',
              total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024) + 'MB'
            } : 'Not available'
          });
        }

        //setTimeout(logPerformance, 2000);

      </script>

      <div class="edits">
        <div>
          <label>Current Step</label>
          <input type="tel" value="4" name="currentStep"/>
        </div>

        <div>
          <label>Total Steps</label>
          <input type="tel" value="9" name="totalSteps"/>
        </div>
        <div>
          <button onclick="changeJourney()">Reset</button>
        </div>
      </div>
  </body>
</html>
